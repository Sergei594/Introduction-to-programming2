
// У нас получилась матрица или прямоугольная таблица чисел с тремя строками и четырьмя столбцами.
// Важно, что 3 и 4 (int[,] matrix = new int[3, 4]), которые определены для самого массива,
// можно оставить, потому что при инициализации массива вы всегда должны определить, сколько
// памяти нужно выделить. А вот в момент, когда вы будете работать, например, в циклах или методах,
// можно получить количество строк и другим способом. Для тройки указываем имя массива и новый
// функционал GetLength(0). 0 в качестве аргумента означает количество строк. Аналогично и для
// четвёрки: пишем имя массива, точку и GetLength(1).


// int[,] matrix = new int[3, 4];

// for (int i = 0; i < 3; i++)
// {
//     for (int j = 0; j < 4; j++)
//     {
//         Console.Write($"{matrix[i, j]} ");
//     }
//     Console.WriteLine;

// }


// Теперь попробуем воспользоваться знаниями с предыдущих лекций и опишем метод, который будет
// отдельно печатать двумерную матрицу на экран и заполнять её числами. Итак, поехали.
// Учитывая тот факт, что мы плюс-минус знаем, как это делается, можем немножко схитрить. Для
// текущего кода сделаем обрамление в виде метода. Делаем отступы, чтобы всё было красиво. В
// качестве аргумента передаём прямоугольную таблицу чисел. Вместо matrix будем передавать
// сокращённое название — matr. Метод PrintArray в качестве аргумента принимает двумерную таблицу
// чисел и будет печатать её на экран. В качестве аргумента передаём ту матрицу, которая была
// определена чуть раньше. Чтобы код был более скомпонованным, инициализацию массива перенесём
// поближе к вызову печати.

// void PrintArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             Console.Write($"{matr[i, j]} ");
//         }
//         Console.WriteLine();
//     }
// }
// int[,] matrix = new int[3, 4];
// PrintArray(matrix);


// Теперь опишем дополнительный метод, который будет заполнять нашу матрицу случайными числами.
// Здесь всё почти так же, как с одномерными массивами. Для i указываем matr.GetLength(0), для J —
// matr.GetLength(1). Затем обращаемся к конкретному элементу на позиции «итый-житый» и пишем
// через использование генератора псевдослучайных чисел. Возьмём полуинтервал от 1 до 10.
// Напоминаю, из-за круглых скобок может показаться, что это интервал (как в математике), но у нас
// получается именно полуинтервал.
// Проверим работоспособность нашего метода. Сначала инициализируемся, убедимся, что у нас нули.
// Затем сделаем FillArray, в качестве аргумента передадим наш массив и снова распечатаем. А чтобы
// отделить нули от чисел, перед финальной распечаткой добавим Console.WriteLine().

// void PrintArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             Console.Write($"{matr[i, j]} ");
//         }
//         Console.WriteLine();
//     }
// }
// void FillArray(int[,] matr)
// {
//     for (int i = 0; i < matr.GetLength(0); i++)
//     {
//         for (int j = 0; j < matr.GetLength(1); j++)
//         {
//             matr[i, j] = new Random().Next(1, 10);//[1; 10)
//         }
//     }
// }
// int[,] matrix = new int[3, 4];
// PrintArray(matrix);
// FillArray(matrix);
// Console.WriteLine();
// PrintArray(matrix);





// Далее мы должны определить порядок действий. Я договариваюсь ходить сначала вверх, потом
// влево, вниз и вправо. Всё ровно так, как на примере с закрашиванием пикселей.
// Теперь давайте попробуем написать код, который позволит нам взять картинку и закрасить область
// внутри контура.

int[,] pic = new int[,]
{
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 },
{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 },
{0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 },
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
};
void PrintImage(int[,] image)
{
    for (int i = 0; i < image.GetLength(0); i++)
    {
        for (int j = 0; j < image.GetLength(1); j++)
        {
            if (image[i, j] == 0) Console.Write($" ");
            else Console.Write($"+");
        }
        Console.WriteLine();
    }
}
PrintImage(pic);

// Дальше предлагаю описать метод, который будет закрашивать картинку. По аналогии назовём его
// FillImage. А в качестве аргумента я укажу позицию строки и пикселя, с которого мы должны будем
// начать закраску. Дальше я проверяю условие: если текущий пиксель (pic) с указанной позицией (row,
// col) равен нулю (то есть не закрашен), я буду его красить единичкой. А дальше вызову FillImage. И
// здесь мы определяем правило — что за чем идёт. Сначала поднимаемся на строчку выше (row-1, col),
// потом идём влево (row, col-1), потом вниз (row+1, col), потом вправо (row, col+1).


void FillImage(int row, int col)
{
    if (pic[row, col] == 0)
    {
        pic[row, col] = 1;
        FillImage(row - 1, col);
        FillImage(row, col - 1);
        FillImage(row + 1, col);
        FillImage(row, col + 1);
    }
}
PrintImage(pic);
FillImage(13, 13);
PrintImage(pic);




// Вычисление факториала
// Определим метод как возвращающий int, и в качестве аргумента принимающий другое целое число.
// Далее по определению факториала мы явно укажем: «если мы дошли до единицы (n = 1), мы должны
// вернуть 1». Почему? Это определение факториала: 1! = 1. Кстати, отметим, что 0! — это тоже 1.
// Итак, если n = 1, возвращаем 1. В противном случае берём екущее значение и умножаем на факториал
// предыдущего числа (n - 1). Не забываем, что мы должны явно возвращать значение. То есть, если 1,
// возвращаем 1. Если не 1, то n * Factorial(n-1) (факториал предыдущего числа

// int Factorial(int n)
// {
// // 1! = 1
// // 0! = 1
// if(n == 1) return 1;
// else return n * Factorial(n-1);
// }
// Console.WriteLine(Factorial(3)); // 1 * 2 * 3 = 6


// Дальше, если попытаемся вычислить 5!, получим 120 — всё правильно.
// Казалось бы, задачу решили. Но есть проблема: когда мы будем вычислять большие числа (допустим,
// 40!), в какой-то момент начнём получать отрицательные числа, чего быть не должно.

// int Factorial(int n)
// {
// // 1! = 1
// // 0! = 1
// if(n == 1) return 1;
// else return n * Factorial(n-1);
// }
// for (int i = 1; i < 40; i++)
// {
// Console.WriteLine($"{i}! = {Factorial(i)}");
// }


// double - позволяет работать с большими числами


// double Factorial(int n)
// {
// // 1! = 1
// // 0! = 1
// if(n == 1) return 1;
// else return n * Factorial(n-1);
// }
// for (int i = 1; i < 40; i++)
// {
// Console.WriteLine($"{i}! = {Factorial(i)}");
// }



// У нас есть функция, которая будет что-то возвращать (начнём пока с целых чисел). Определяем её
// наименование — Fibonacci. В качестве аргумента указываем n. Если значение n=1 или n=2, возвращаем
// 1. Иначе мы хотим вернуть Fibonacci(n-1) + Fibonacci(n-2).

// f(1) = 1
// f(2) = 1
// f(n) = f(n-1) + f(n-2)

// int Fibonacci(int n)
// {
// if(n == 1 || n == 2) return 1;
// else return Fibonacci(n-1) + Fibonacci(n-2);
// }
// for (int i = 1; i < 10; i++)
// {
// Console.WriteLine(Fibonacci(i));
// }

// Получаются те самые числа Фибоначчи — каждое равно сумме двух предыдущих.
// Есть тонкий момент. По аналогии с факториалом попробуем посчитать первые 50 чисел Фибоначчи так,
// чтобы возвращалось double-значение.

// double Fibonacci(int n)
// {
// if(n == 1 || n == 2) return 1;
// else return Fibonacci(n-1) + Fibonacci(n-2);
// }
// for (int i = 1; i < 50; i++)
// {
// Console.WriteLine(Fibonacci(i));
// }

// Первые числа вылетят в консоль достаточно быстро, а дальше она начнёт работать медленнее.
// Попробуем понять, с какого числа начинается проблема.

// double Fibonacci(int n)
// {
// if(n == 1 || n == 2) return 1;
// else return Fibonacci(n-1) + Fibonacci(n-2);
// }
// for (int i = 1; i < 50; i++)
// {
// Console.WriteLine($"f({i}) = {Fibonacci(i)}");
// }

// Начиная с сорокового числа значения выводятся очень медленно. С чем это связано, обязательно
// обсудим на семинаре. Но сразу отмечу, что рекурсию можно сделать более шустрой. Можно ли
// заменить рекурсию другими конструкциями (в частности, циклом) — да, можно. Именно этим мы
// займёмся на семинаре.